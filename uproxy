#! /usr/bin/perl
# micro HTTP caching proxy
# (c) 2015 - GPL2 - Steve Schnepp <steve.schnepp@pwkf.org>
#
# It uses only core Perl modules, and is aimed for low perf hardware, such as
# embedded NAS, where you only have a raw Perl, and installing deps is
# cumbersome.
#
# TODO - It might make sense to rewrite this in C

use warnings;
use strict;

use File::stat;
use File::Path qw(make_path);
use File::Basename;
use IO::Socket::INET;

my $BUFFER_SIZE = 64 * 1024; # 64k buffer
my $CACHEDIR = "cache"; # default is $(pwd)/cache
my $PORT = 3128;

# Make & go to $CACHEDIR, so everything is relative to it
make_path($CACHEDIR);
chdir $CACHEDIR;

my $listen = IO::Socket::INET->new(
	Listen => 5,
	LocalPort => $PORT,
	Proto => "tcp",
	ReuseAddr => 1,
);

print STDERR "Listening on $PORT\n" if $ENV{DEBUG};

while (my $accept = $listen->accept()) {
	$_ = <$accept>;
	s/\n$//; s/\r$//;
	my ($method, $url, $version) = split(/ +/, $_);
	print STDERR "$method, $url, $version\n" if $ENV{DEBUG};

	# Support only GET
	next unless $method eq "GET";

	# Fetch the request headers
	my %headers;
	while (<$accept>) {
		s/\n$//; s/\r$//;
		print STDERR "'$_'\n" if $ENV{DEBUG};

		last unless $_; # stop on empty line
		next unless m/^([^:]+): (.+)$/;

		$headers{$1} = $2;
	}

	# Parse the URL
	next unless $url =~ m,^([^:]+)://([^/]+)/(.*)$,;
	my ($scheme, $host, $fullpath) = ($1, $2, $3);
	print STDERR "$scheme, $host, $fullpath\n" if $ENV{DEBUG};

	# Support only HTTP (no SSL)
	next unless lc($scheme) eq "http";

	my ($url_path, $query_string) = split(/\?/, $fullpath, 2);
	print STDERR "$url_path, $query_string\n" if $ENV{DEBUG};

	# Sanitize $url_path & $query_string
	$url_path =~ s,/\.\./,%2F..%2F%0A,g;
	$query_string =~ s,/,%2F,g if $query_string;

	my $cache_filename = "$CACHEDIR/$url_path";
	$cache_filename .= "?" . $query_string if $query_string;

	my $st = stat($cache_filename);
	goto REQUEST_DIRECT unless $st; # No cache, requesting from origin

	# Fetch the stored header

	my $upstream;
	my %reply_headers;
	($reply_version, $status, $comment) = split(/ +/, $_, 3);

	$upstream = IO::File->new("$cache_filename");

	%reply_headers = (
		"Content-Length" => $st->size,
	);

	goto SEND_DOWNSTREAM;

REQUEST_DIRECT:
	# Set the default port
	$host .= ":80" unless $host =~ m/:/;

	$upstream = IO::Socket::INET->new(
		PeerAddr => $host,
		Proto => "tcp",
	);

	print STDERR "$upstream\n" if $ENV{DEBUG};
	next unless $upstream;

	print $upstream "GET /$fullpath HTTP/1.0\r\n";
	print $upstream "Connection: close\r\n"; # NO keepalive

	# Only send Host header, if present
	print $upstream "Host: ". $headers{Host} . "\r\n" if $headers{Host};

	# That's it!
	print $upstream "\r\n";

	# Now, just stream it back to the client
	$_ = <$upstream>;
	s/\n$//; s/\r$//;
	($reply_version, $status, $comment) = split(/ +/, $_, 3);
	print STDERR "$reply_version, $status, $comment\n" if $ENV{DEBUG};

	# Only supporting HTTP 200 OK and 301/302 REDIRECTS
	next unless $status =~ m/^(200|301|302)$/;

	# fetch reply headers
	while (<$upstream>) {
		s/\n$//; s/\r$//;
		print STDERR "'$_'\n" if $ENV{DEBUG};

		last unless $_; # stop on empty line
		next unless m/^([^:]+): (.+)$/;

		$reply_headers{$1} = $2;
	}

	# Ensure the directory exists
	my $cache_dirname = dirname($cache_filename);
	print STDERR "$cache_filename, $cache_dirname\n" if $ENV{DEBUG};
	make_path($cache_dirname);

	my $cache_file = IO::File->new("$cache_filename", "w");

SEND_DOWNSTREAM:
	# Send selected reply headers
	print $accept "HTTP/1.0 $status $comment\r\n"; # HTTP/1.0 is hard coded
	print $accept "Location: " . $reply_headers{"Location"} . "\r\n" if $reply_headers{"Location"};
	print $accept "Date: " . $reply_headers{"Date"} . "\r\n" if $reply_headers{"Date"};
	print $accept "Content-Type: " . $reply_headers{"Content-Type"} . "\r\n" if $reply_headers{"Content-Type"};
	print $accept "Content-Length: " . $reply_headers{"Content-Length"} . "\r\n" if $reply_headers{"Content-Length"};
	print $accept "Transfer-Encoding: " . $reply_headers{"Transfer-Encoding"} . "\r\n" if $reply_headers{"Transfer-Encoding"};

	print $accept "Age: " . $reply_headers{"Age"} . "\r\n" if $reply_headers{"Age"};
	print $accept "Expires: " . $reply_headers{"Expires"} . "\r\n" if $reply_headers{"Expires"};
	print $accept "Cache-Control: " . $reply_headers{"Cache-Control"} . "\r\n" if $reply_headers{"Cache-Control"};

	print $accept "Connection: close\r\n"; # No KeepAlive.

	print $accept "\r\n";

	# pass upstream to downstream, and writing it locally
	copy_data_mono($upstream, $accept, $cache_file);
}

sub copy_data_mono {
	my $src = shift;
	my @dsts = @_;

	my $buf;
	while (my $read_len = read($src, $buf, $BUFFER_SIZE)) {
		for my $dst (@dsts) {
			# Ignore undef $dst, this makes it much more flexible
			next unless $dst;

			# write() is *not* the opposite of read(), print() is.
			print $dst $buf;
		}
	}
}
